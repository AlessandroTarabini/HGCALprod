// -*- C++ -*-
//
// Package:    test/PUmitigationG
// Class:      PUmitigationG
//
/**\class PUmitigationG PUmitigationG.cc test/PUmitigationG/plugins/PUmitigationG.cc

 Description: [one line class summary]

 Implementation:
     [Notes on implementation]
*/
//
// Original Author:  Loukas Gouskos
//         Created:  Sun, 26 May 2019 21:36:19 GMT
//
//

// system include files
#include <memory>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/one/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "FWCore/Utilities/interface/InputTag.h"

#include "DataFormats/DetId/interface/DetId.h"
#include "Geometry/CaloTopology/interface/HGCalTopology.h"
#include "Geometry/HGCalGeometry/interface/HGCalGeometry.h"
#include "Geometry/CaloGeometry/interface/CaloGeometry.h"
#include "Geometry/Records/interface/CaloGeometryRecord.h"

#include "DataFormats/CaloRecHit/interface/CaloClusterFwd.h"
#include "DataFormats/HGCRecHit/interface/HGCRecHitCollections.h"
#include "DataFormats/ForwardDetId/interface/HGCalDetId.h"
#include "DataFormats/HGCRecHit/interface/HGCRecHit.h"

#include "RecoLocalCalo/HGCalRecAlgos/interface/RecHitTools.h"

#include "SimDataFormats/CaloAnalysis/interface/CaloParticle.h"
#include "SimDataFormats/CaloAnalysis/interface/CaloParticleFwd.h"

#include "SimDataFormats/CaloAnalysis/interface/SimClusterFwd.h"
#include "SimDataFormats/CaloAnalysis/interface/SimCluster.h"

#include "SimDataFormats/Vertex/interface/SimVertex.h"
#include "RecoLocalCalo/HGCalRecProducers/interface/HGCalClusteringAlgoBase.h"

#include "DataFormats/ParticleFlowReco/interface/HGCalMultiCluster.h"
#include "DataFormats/Common/interface/ValueMap.h"

// form HGC Validator code
#include "Validation/HGCalValidation/interface/HGVHistoProducerAlgo.h"

#include "DataFormats/Math/interface/LorentzVector.h"

#include "DataFormats/HGCalReco/interface/Trackster.h"

//ROOT includes
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "TTree.h"
#include <TFile.h>
#include <TROOT.h>
#include "TBranch.h"
#include <string>
#include <vector>
#include "TSystem.h"
#include "TVector3.h"
#include "TLorentzVector.h"
#include "TH1.h"
#include <algorithm>

// Common Data Formats used by the ntuple
#include "CommonDataFormats.h"
//
// class declaration
//

// If the analyzer does not use TFileService, please remove
// the template argument to the base class so the class inherits
// from  edm::one::EDAnalyzer<>
// This will improve performance in multithreaded jobs.

class PUmitigationG : public edm::one::EDAnalyzer<edm::one::SharedResources> {
public:
  explicit PUmitigationG(const edm::ParameterSet&);
  ~PUmitigationG();

  static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);

private:
  virtual void beginJob() override;
  virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
  virtual void endJob() override;
  virtual void fillHitMap(std::map<DetId, const HGCRecHit*>& hitMap,
                          const HGCRecHitCollection& rechitsEE,
                          const HGCRecHitCollection& rechitsFH,
                          const HGCRecHitCollection& rechitsBH) const;

  std::shared_ptr<hgcal::RecHitTools> recHitTools;
  //const hgcal::RecHitTools recHitTools;

  // ----------member data ---------------------------
  edm::EDGetTokenT<std::vector<CaloParticle>> caloParticlesToken_;
  edm::EDGetTokenT<HGCRecHitCollection> hgcalRecHitsEEToken_;
  edm::EDGetTokenT<HGCRecHitCollection> hgcalRecHitsFHToken_;
  edm::EDGetTokenT<HGCRecHitCollection> hgcalRecHitsBHToken_;
  // edm::EDGetTokenT<std::vector<reco::HGCalMultiCluster>> emMCsToken_;
  // edm::EDGetTokenT<std::vector<reco::HGCalMultiCluster>> hadMCsToken_;
  edm::EDGetTokenT<reco::CaloClusterCollection> hgcalLayerClustersToken_;
  edm::EDGetTokenT<edm::ValueMap<float>> hgcalLayerClusterTimeToken_;

  edm::EDGetTokenT<std::vector<ticl::Trackster>> trackstersEM_;
  edm::EDGetTokenT<std::vector<ticl::Trackster>> trackstersHAD_;
  edm::EDGetTokenT<std::vector<ticl::Trackster>> trackstersMIP_;
  edm::EDGetTokenT<std::vector<ticl::Trackster>> trackstersTrk_;

  TTree* tree = new TTree("tree", "tree");

  edm::RunNumber_t irun;
  edm::EventNumber_t ievent;
  edm::LuminosityBlockNumber_t ilumiblock;
  edm::Timestamp itime;

  size_t run, event, lumi, time;

  std::vector<int> lc_type;
  std::vector<float> lc_energy;
  std::vector<float> lc_eta;
  std::vector<float> lc_phi;
  std::vector<float> lc_layer;
  std::vector<std::vector<unsigned int>> tracksterEM_clusters;
  std::vector<std::vector<unsigned int>> tracksterHAD_clusters;
  std::vector<std::vector<unsigned int>> tracksterMIP_clusters;
  std::vector<std::vector<unsigned int>> tracksterTrk_clusters;
};

//
// constants, enums and typedefs
//

//
// static data member definitions
//

//
// constructors and destructor
//
PUmitigationG::PUmitigationG(const edm::ParameterSet& iConfig)
  : caloParticlesToken_(consumes<std::vector<CaloParticle>>(iConfig.getParameter<edm::InputTag>("caloParticles"))),
    hgcalRecHitsEEToken_(consumes<HGCRecHitCollection>(iConfig.getParameter<edm::InputTag>("hgcalRecHitsEE"))),
    hgcalRecHitsFHToken_(consumes<HGCRecHitCollection>(iConfig.getParameter<edm::InputTag>("hgcalRecHitsFH"))),
    hgcalRecHitsBHToken_(consumes<HGCRecHitCollection>(iConfig.getParameter<edm::InputTag>("hgcalRecHitsBH"))),
    // emMCsToken_(consumes<std::vector<reco::HGCalMultiCluster>>(iConfig.getParameter<edm::InputTag>("emMCs"))),
    // hadMCsToken_(consumes<std::vector<reco::HGCalMultiCluster>>(iConfig.getParameter<edm::InputTag>("hadMCs"))),
    hgcalLayerClustersToken_(
			     consumes<reco::CaloClusterCollection>(iConfig.getParameter<edm::InputTag>("hgcalLayerClusters"))),
  hgcalLayerClusterTimeToken_(
			      consumes<edm::ValueMap<float>>(iConfig.getParameter<edm::InputTag>("layerClusterTime"))),
  trackstersEM_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("trackstersEM"))),
  trackstersHAD_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("trackstersHAD"))),
  trackstersMIP_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("trackstersMIP"))),
  trackstersTrk_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("trackstersTrk"))) {
  recHitTools.reset(new hgcal::RecHitTools());
  //now do what ever initialization is needed
  usesResource("TFileService");
  edm::Service<TFileService> file;

  tree = file->make<TTree>("tree", "hgc analyzer");

  tree->Branch("lc_type", &lc_type);
  tree->Branch("lc_energy", &lc_energy);
  tree->Branch("lc_eta", &lc_eta);
  tree->Branch("lc_phi", &lc_phi);
  tree->Branch("lc_layer", &lc_layer);
  tree->Branch("tracksterEM_clusters", &tracksterEM_clusters);
  tree->Branch("tracksterHAD_clusters", &tracksterHAD_clusters);
  tree->Branch("tracksterMIP_clusters", &tracksterMIP_clusters);
  tree->Branch("tracksterTrk_clusters", &tracksterTrk_clusters);
}

PUmitigationG::~PUmitigationG() {
  // do anything here that needs to be done at desctruction time
  // (e.g. close files, deallocate resources etc.)
}

//
// member functions
//

// ------------ method called for each event  ------------

void PUmitigationG::fillHitMap(std::map<DetId, const HGCRecHit*>& hitMap,
                               const HGCRecHitCollection& rechitsEE,
                               const HGCRecHitCollection& rechitsFH,
                               const HGCRecHitCollection& rechitsBH) const {
  hitMap.clear();
  for (const auto& hit : rechitsEE) {
    hitMap.emplace(hit.detid(), &hit);
  }

  for (const auto& hit : rechitsFH) {
    hitMap.emplace(hit.detid(), &hit);
  }

  for (const auto& hit : rechitsBH) {
    hitMap.emplace(hit.detid(), &hit);
  }
}

void PUmitigationG::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) {
  using namespace edm;

  edm::Handle<HGCRecHitCollection> recHitHandleEE;
  iEvent.getByToken(hgcalRecHitsEEToken_, recHitHandleEE);

  edm::Handle<HGCRecHitCollection> recHitHandleFH;
  iEvent.getByToken(hgcalRecHitsFHToken_, recHitHandleFH);

  edm::Handle<HGCRecHitCollection> recHitHandleBH;
  iEvent.getByToken(hgcalRecHitsBHToken_, recHitHandleBH);

  //  edm::Handle<std::vector<reco::HGCalMultiCluster>> mcEMHandle;
  //  iEvent.getByToken(emMCsToken_, mcEMHandle);
  //  const std::vector<reco::HGCalMultiCluster> &emMCs = *mcEMHandle;

  //  edm::Handle<std::vector<reco::HGCalMultiCluster>> mcHadHandle;
  //  iEvent.getByToken(hadMCsToken_, mcHadHandle);
  //  const std::vector<reco::HGCalMultiCluster> &hadMCs = *mcHadHandle;

  edm::Handle<std::vector<CaloParticle>> CaloParticles;
  iEvent.getByToken(caloParticlesToken_, CaloParticles);
  const CaloParticleCollection& cps = *CaloParticles;

  edm::Handle<reco::CaloClusterCollection> layerClusterHandle;
  iEvent.getByToken(hgcalLayerClustersToken_, layerClusterHandle);
  const reco::CaloClusterCollection& lcs = *layerClusterHandle;

  std::map<DetId, const HGCRecHit*> hitMap;
  fillHitMap(hitMap, *recHitHandleEE, *recHitHandleFH, *recHitHandleBH);
  std::unordered_map<DetId, std::vector<HGVHistoProducerAlgo::detIdInfoInCluster>> detIdToCaloParticleId_Map;

  edm::Handle<edm::ValueMap<float>> lcTimeHandle;
  iEvent.getByToken(hgcalLayerClusterTimeToken_, lcTimeHandle);
  const auto& lcTime = *lcTimeHandle;

  edm::Handle<std::vector<ticl::Trackster>> trackstersEMHandle;
  iEvent.getByToken(trackstersEM_, trackstersEMHandle);
  const std::vector<ticl::Trackster>& trackstersEM = (*trackstersEMHandle);

  edm::Handle<std::vector<ticl::Trackster>> trackstersHADHandle;
  iEvent.getByToken(trackstersHAD_, trackstersHADHandle);
  const std::vector<ticl::Trackster>& trackstersHAD = (*trackstersHADHandle);

  edm::Handle<std::vector<ticl::Trackster>> trackstersMIPHandle;
  iEvent.getByToken(trackstersMIP_, trackstersMIPHandle);
  const std::vector<ticl::Trackster>& trackstersMIP = (*trackstersMIPHandle);

  edm::Handle<std::vector<ticl::Trackster>> trackstersTrkHandle;
  iEvent.getByToken(trackstersTrk_, trackstersTrkHandle);
  const std::vector<ticl::Trackster>& trackstersTrk = (*trackstersTrkHandle);

  // init vars
  //recHitTools->getEventSetup(iSetup);
  std::vector<DetId> cp_detid_v;
  cp_detid_v.clear();

  lc_type.clear();
  lc_energy.clear();
  lc_eta.clear();
  lc_phi.clear();
  lc_layer.clear();

  tracksterEM_clusters.clear();
  tracksterHAD_clusters.clear();
  tracksterMIP_clusters.clear();
  tracksterTrk_clusters.clear();

  // get CaloParticles
  unsigned int count_cp = 0;
  for (const auto& it_cp : cps) {
    const CaloParticle& cp = ((it_cp));

    if ((cp.eventId().event() != 0) || (cp.eventId().bunchCrossing() != 0) || (count_cp != 0)) {
      continue;
    }
    count_cp = 1;

    // get the simclusters
    const SimClusterRefVector& simclusters = cp.simClusters();
    for (const auto& it_simc : simclusters) {
      const SimCluster& simc = (*(it_simc));
      const auto& sc_haf = simc.hits_and_fractions();

      // get the rechits
      for (const auto& it_sc_haf : sc_haf) {
        DetId detid_ = (it_sc_haf.first);

        // need to map RecHits to the SimCluster
        // SimHits are not stored
	std::map<DetId, const HGCRecHit*>::const_iterator itcheck = hitMap.find(detid_);
        // we need this check because some DetIDs assigned to CaloParticle do not always have
        // a RecHit -- due to thresholds or whatever
        if (itcheck != hitMap.end()) {
          const HGCRecHit* hit = itcheck->second;
          cp_detid_v.push_back(detid_);

        }  //  end of if(itcheck != hitMap.end())
      }
    }
  }  // end of looping over the calo particles

  // loop over the LayerClusters
  for (const auto& it_lc : lcs) {
    bool isFromCP_ = false;

    const reco::CaloCluster& lc = ((it_lc));
    const std::vector<std::pair<DetId, float>>& hf = lc.hitsAndFractions();

    int layer_ = 0;
    for (unsigned int j = 0; j < hf.size(); j++) {
      DetId rh_detid = hf[j].first;
      layer_ = recHitTools->getLayerWithOffset(rh_detid);
      if (std::find(cp_detid_v.begin(), cp_detid_v.end(), rh_detid) != cp_detid_v.end()) {
        isFromCP_ = true;  // found a match; do not look furthers in this LC [for now]
      }

      if (isFromCP_) {
        break;
      }
    }

    if (isFromCP_) {
      lc_type.push_back(1);
    } else {
      lc_type.push_back(0);
    }
    lc_energy.push_back(it_lc.energy());
    lc_eta.push_back(it_lc.eta());
    lc_phi.push_back(it_lc.phi());
    lc_layer.push_back(layer_);

  }  // end of looping over the LC

  // fill tracksters
  unsigned int ntracksterEM = 0;
  unsigned int ntracksterHAD = 0;
  unsigned int ntracksterMIP = 0;
  unsigned int ntracksterTrk = 0;

  ntracksterEM = trackstersEM.size();
  for (unsigned it = 0; it < ntracksterEM; ++it) {
    std::vector<unsigned int> ids;
    for (unsigned int i = 0; i < trackstersEM[it].vertices().size(); i++)
      ids.push_back(trackstersEM[it].vertices().at(i));

    tracksterEM_clusters.push_back(ids);
  }

  ntracksterHAD = trackstersHAD.size();
  for (unsigned it = 0; it < ntracksterHAD; ++it) {
    std::vector<unsigned int> ids;
    for (unsigned int i = 0; i < trackstersHAD[it].vertices().size(); i++)
      ids.push_back(trackstersHAD[it].vertices().at(i));

    tracksterHAD_clusters.push_back(ids);
  }

  ntracksterMIP = trackstersMIP.size();
  for (unsigned it = 0; it < ntracksterMIP; ++it) {
    std::vector<unsigned int> ids;
    for (unsigned int i = 0; i < trackstersMIP[it].vertices().size(); i++)
      ids.push_back(trackstersMIP[it].vertices().at(i));

    tracksterMIP_clusters.push_back(ids);
  }

  ntracksterTrk = trackstersTrk.size();
  for (unsigned it = 0; it < ntracksterTrk; ++it) {
    std::vector<unsigned int> ids;
    for (unsigned int i = 0; i < trackstersTrk[it].vertices().size(); i++)
      ids.push_back(trackstersTrk[it].vertices().at(i));

    tracksterTrk_clusters.push_back(ids);
  }

  tree->Fill();

#ifdef THIS_IS_AN_EVENTSETUP_EXAMPLE
  ESHandle<SetupData> pSetup;
  iSetup.get<SetupRecord>().get(pSetup);
#endif
}

// ------------ method called once each job just before starting event loop  ------------
void PUmitigationG::beginJob() {}

// ------------ method called once each job just after ending the event loop  ------------
void PUmitigationG::endJob() {}

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void PUmitigationG::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);

  //Specify that only 'tracks' is allowed
  //To use, remove the default given above and uncomment below
  //ParameterSetDescription desc;
  //desc.addUntracked<edm::InputTag>("tracks","ctfWithMaterialTracks");
  //descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(PUmitigationG);
