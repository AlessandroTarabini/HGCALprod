// system include files
#include <memory>
#include <algorithm>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/one/EDAnalyzer.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"

#include "FWCore/Utilities/interface/InputTag.h"

#include "DataFormats/DetId/interface/DetId.h"
#include "Geometry/CaloTopology/interface/HGCalTopology.h"
#include "Geometry/HGCalGeometry/interface/HGCalGeometry.h"
#include "Geometry/CaloGeometry/interface/CaloGeometry.h"
#include "Geometry/Records/interface/CaloGeometryRecord.h"

#include "DataFormats/CaloRecHit/interface/CaloClusterFwd.h"
#include "DataFormats/HGCRecHit/interface/HGCRecHitCollections.h"
#include "DataFormats/ForwardDetId/interface/HGCalDetId.h"
#include "DataFormats/HGCRecHit/interface/HGCRecHit.h"
#include "DataFormats/Math/interface/deltaR.h"

#include "RecoLocalCalo/HGCalRecAlgos/interface/RecHitTools.h"

#include "SimDataFormats/CaloAnalysis/interface/CaloParticle.h"
#include "SimDataFormats/CaloAnalysis/interface/CaloParticleFwd.h"

#include "SimDataFormats/CaloAnalysis/interface/SimClusterFwd.h"
#include "SimDataFormats/CaloAnalysis/interface/SimCluster.h"

#include "SimDataFormats/Vertex/interface/SimVertex.h"
#include "RecoLocalCalo/HGCalRecProducers/interface/HGCalClusteringAlgoBase.h"

#include "DataFormats/ParticleFlowReco/interface/HGCalMultiCluster.h"
#include "DataFormats/Common/interface/ValueMap.h"

// from HGC Validator code
//#include "Validation/HGCalValidation/interface/HGVHistoProducerAlgo.h"

#include "DataFormats/Math/interface/LorentzVector.h"

#include "DataFormats/HGCalReco/interface/Trackster.h"

//ROOT includes
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "TTree.h"
#include <TFile.h>
#include <TROOT.h>
#include "TBranch.h"
#include <string>
#include <vector>
#include "TSystem.h"
#include "TVector3.h"
#include "TLorentzVector.h"
#include "TH1.h"

// Common Data Formats used by the ntuple
#include "CommonDataFormats.h"

bool sortLCsByEnergyAndLayer(const layercluster& a, const layercluster& b) {
  return (a.energy_ > b.energy_) || ((a.energy_ == b.energy_) && (a.layer_ < b.layer_));
}
bool sortLCsByLayerAndEnergy(const layercluster& a, const layercluster& b) {
  return (a.layer_ < b.layer_) || ((a.layer_ == b.layer_) && (a.energy_ > b.energy_));
}

double cosTheta(const ROOT::Math::XYZVector & AC,
		const ROOT::Math::XYZVector & AB){
  
  return sqrt( AC.Dot(AB)*AC.Dot(AB) / (AC.Mag2()*AB.Mag2()) );
  
};

class HGCANALYZE : public edm::one::EDAnalyzer<edm::one::SharedResources> {
public:
  explicit HGCANALYZE(const edm::ParameterSet&);
  ~HGCANALYZE() override;

  static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);

private:
  void beginJob() override;
  void analyze(const edm::Event&, const edm::EventSetup&) override;
  void endJob() override;
  virtual void fillHitMap(std::map<DetId, const HGCRecHit*>& hitMap,
                          const HGCRecHitCollection& rechitsEE,
                          const HGCRecHitCollection& rechitsFH,
                          const HGCRecHitCollection& rechitsBH) const;
  std::vector<int> getClosestTrackstersToCPByIndex(const caloparticle& cp,
						   const reco::CaloClusterCollection& lcs,
                                                   const std::vector<ticl::Trackster>& trkster,
                                                   float maxDrTrksterCP);
  int isRecHitMatchedToCPRecHits(DetId detid_, const std::vector<DetId>& rechitdetid_);
  double getTrksterEnFromCP(const ticl::Trackster& trkster,
			    const reco::CaloClusterCollection& lcs,
			    const caloparticle& cp);
  void fillLCvector(std::vector<layercluster> & aLCvec,
		    const reco::BasicCluster& aLC,
		    const int & tsMult);
  void getLCs(const reco::CaloClusterCollection& lcs, std::vector<layercluster> & out);
  void getLCsFromTrkster(const ticl::Trackster& trkster, const reco::CaloClusterCollection& lcs, std::vector<layercluster> & out);

  void initialiseTreeVariables();

  void fillDoubletsInfo(const ticl::Trackster & thisTrackster,
			const reco::CaloClusterCollection &  layerClusters
			);

  std::shared_ptr<hgcal::RecHitTools> recHitTools;
  
  // ----------member data ---------------------------
  edm::EDGetTokenT<std::vector<CaloParticle>> caloParticlesToken_;
  edm::EDGetTokenT<HGCRecHitCollection> hgcalRecHitsEEToken_;
  edm::EDGetTokenT<HGCRecHitCollection> hgcalRecHitsFHToken_;
  edm::EDGetTokenT<HGCRecHitCollection> hgcalRecHitsBHToken_;

  //edm::EDGetTokenT<std::vector<ticl::Trackster> > dummyTrksterToken_;
  //edm::EDGetTokenT<std::vector<ticl::Trackster> > emTrksterToken_;
  //edm::EDGetTokenT<std::vector<ticl::Trackster> > trkTrksterToken_;
  //edm::EDGetTokenT<std::vector<ticl::Trackster> > hadTrksterToken_;
  //edm::EDGetTokenT<std::vector<ticl::Trackster> > mipTrksterToken_;
  edm::EDGetTokenT<std::vector<ticl::Trackster> > mergeTrksterToken_;
  edm::EDGetTokenT<reco::CaloClusterCollection> hgcalLayerClustersToken_;
  edm::EDGetTokenT<edm::ValueMap<std::pair<float, float> > > hgcalLayerClusterTimeToken_;

  TTree* tree = new TTree("tree", "tree");

  edm::RunNumber_t irun;
  edm::EventNumber_t ievent;
  edm::LuminosityBlockNumber_t ilumiblock;
  edm::Timestamp itime;

  //size_t run, event, lumi, time;
  size_t run, lumi, time;
  int event;
  double weight;

  int nTS;
  int trackster;
  double ts_energy;
  double ts_emEnergy;
  double ts_regEnergy;
  double ts_sigma1;
  double ts_sigma2;
  double ts_sigma3;
  double ts_BCx;
  double ts_BCy;
  double ts_BCz;
  double ts_eta_PCA;
  double ts_phi_PCA;
  double ts_eta_fromLC;
  double ts_phi_fromLC;
  double ts_photon_proba;
  double ts_ele_proba;
  double ts_mu_proba;
  double ts_pi0_proba;
  double ts_chHad_proba;
  double ts_neHad_proba;
  double ts_ambg_proba;
  double ts_unkwn_proba;
  int ts_firstLayer;
  int ts_lastLayer;
  int ts_outInHopsPerformed;

  int nCP;
  double cp_missingEnergyFraction;
  double cp_energy;
  int cp_pdgid;
  double cp_pt;
  double cp_eta;
  double cp_phi;

  
  int nLC;
  std::vector<double> lc_energy;
  std::vector<double> lc_eta;
  std::vector<double> lc_phi;
  std::vector<double> lc_x;
  std::vector<double> lc_y;
  std::vector<double> lc_z;
  std::vector<int> lc_algo;
  std::vector<int> lc_layer;
  std::vector<int> lc_nrechits;
  std::vector<int> lc_tsMult;
  std::vector<int> lc_mult;

  int nAllLC;
  std::vector<double> all_lc_energy;
  std::vector<double> all_lc_eta;
  std::vector<double> all_lc_x;
  std::vector<double> all_lc_y;
  std::vector<double> all_lc_z;
  std::vector<double> all_lc_phi;
  std::vector<int> all_lc_layer;
  std::vector<int> all_lc_nrechits;
  std::vector<int> all_lc_mult;

  const unsigned nL = 28;
  int nTriplets[28];
  std::vector<int> triplets_layerA[28];
  std::vector<int> triplets_layerC[28];
  std::vector<double> triplets_energyA[28];
  std::vector<double> triplets_energyB[28];
  std::vector<double> triplets_energyC[28];
  std::vector<double> triplets_etaB[28];
  std::vector<double> triplets_drB[28];
  std::vector<double> triplets_cosBeta[28];
  std::vector<double> triplets_cosAlphaInner[28];
  std::vector<double> triplets_cosAlphaOuter[28];
  std::vector<int> triplets_inner_in_links[28];
  std::vector<int> triplets_inner_out_links[28];
  std::vector<int> triplets_outer_in_links[28];
  std::vector<int> triplets_outer_out_links[28];
};


HGCANALYZE::HGCANALYZE(const edm::ParameterSet& iConfig):
  caloParticlesToken_(consumes<std::vector<CaloParticle>>(iConfig.getParameter<edm::InputTag>("caloParticles"))),
  hgcalRecHitsEEToken_(consumes<HGCRecHitCollection>(iConfig.getParameter<edm::InputTag>("hgcalRecHitsEE"))),
  hgcalRecHitsFHToken_(consumes<HGCRecHitCollection>(iConfig.getParameter<edm::InputTag>("hgcalRecHitsFH"))),
  hgcalRecHitsBHToken_(consumes<HGCRecHitCollection>(iConfig.getParameter<edm::InputTag>("hgcalRecHitsBH"))),
  //dummyTrksterToken_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("dummyTrkster"))),
  //emTrksterToken_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("emTrkster"))),
//trkTrksterToken_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("trkTrkster"))),
//hadTrksterToken_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("hadTrkster"))),
//mipTrksterToken_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("mipTrkster"))),
  mergeTrksterToken_(consumes<std::vector<ticl::Trackster>>(iConfig.getParameter<edm::InputTag>("mergeTrkster"))),
  hgcalLayerClustersToken_(consumes<reco::CaloClusterCollection>(iConfig.getParameter<edm::InputTag>("hgcalLayerClusters"))),
  hgcalLayerClusterTimeToken_(consumes<edm::ValueMap<std::pair<float, float>>>(iConfig.getParameter<edm::InputTag>("layerClusterTime"))) {
  recHitTools.reset(new hgcal::RecHitTools());
  //now do what ever initialization is needed
  //  usesResource("TFileService");
  usesResource(TFileService::kSharedResource);
  edm::Service<TFileService> file;

  std::cout << " -- Running on EMTracksters: " << iConfig.getParameter<edm::InputTag>("mergeTrkster") << std::endl;


  tree = file->make<TTree>("tree", "pidtree");

  tree->Branch("run", &run, "run/I");
  tree->Branch("event", &event, "event/I");
  tree->Branch("lumi", &lumi, "lumi/I");
  tree->Branch("weight", &weight, "weight/D");
  tree->Branch("nTS", &nTS, "nTS/I");
  tree->Branch("trackster", &trackster, "trackster/I");
  tree->Branch("ts_energy", &ts_energy, "ts_energy/D");
  tree->Branch("ts_emEnergy", &ts_emEnergy, "ts_emEnergy/D");
  tree->Branch("ts_regEnergy", &ts_regEnergy, "ts_regEnergy/D");
  tree->Branch("ts_sigma1", &ts_sigma1, "ts_sigma1/D");
  tree->Branch("ts_sigma2", &ts_sigma2, "ts_sigma2/D");
  tree->Branch("ts_sigma3", &ts_sigma3, "ts_sigma3/D");
  tree->Branch("ts_BCx", &ts_BCx, "ts_BCx/D");
  tree->Branch("ts_BCy", &ts_BCy, "ts_BCy/D");
  tree->Branch("ts_BCz", &ts_BCz, "ts_BCz/D");
  tree->Branch("ts_eta_PCA", &ts_eta_PCA, "ts_eta_PCA/D");
  tree->Branch("ts_phi_PCA", &ts_phi_PCA, "ts_phi_PCA/D");
  tree->Branch("ts_eta_fromLC", &ts_eta_fromLC, "ts_eta_fromLC/D");
  tree->Branch("ts_phi_fromLC", &ts_phi_fromLC, "ts_phi_fromLC/D");
  tree->Branch("ts_photon_proba", &ts_photon_proba, "ts_photon_proba/D");
  tree->Branch("ts_ele_proba", &ts_ele_proba, "ts_ele_proba/D");
  tree->Branch("ts_mu_proba", &ts_mu_proba, "ts_mu_proba/D");
  tree->Branch("ts_pi0_proba", &ts_pi0_proba, "ts_pi0_proba/D");
  tree->Branch("ts_chHad_proba", &ts_chHad_proba, "ts_chHad_proba/D");
  tree->Branch("ts_neHad_proba", &ts_neHad_proba, "ts_neHad_proba/D");
  tree->Branch("ts_ambg_proba", &ts_ambg_proba, "ts_ambg_proba/D");
  tree->Branch("ts_unkwn_proba", &ts_unkwn_proba, "ts_unkwn_proba/D");
  tree->Branch("ts_firstLayer", &ts_firstLayer, "ts_firstLayer/I");
  tree->Branch("ts_lastLayer", &ts_lastLayer, "ts_lastLayer/I");
  tree->Branch("ts_outInHopsPerformed", &ts_outInHopsPerformed, "ts_outInHopsPerformed/I");

  tree->Branch("nCP", &nCP, "nCP/I");
  tree->Branch("cp_missingEnergyFraction", &cp_missingEnergyFraction, "cp_missingEnergyFraction/D");
  tree->Branch("cp_energy", &cp_energy, "cp_energy/D");
  tree->Branch("cp_pt", &cp_pt, "cp_pt/D");
  tree->Branch("cp_eta", &cp_eta, "cp_eta/D");
  tree->Branch("cp_phi", &cp_phi, "cp_phi/D");
  tree->Branch("cp_pdgid", &cp_pdgid, "cp_pdgid/I");

  tree->Branch("nLC", &nLC, "nLC/I");
  tree->Branch("lc_energy", &lc_energy);
  tree->Branch("lc_eta", &lc_eta);
  tree->Branch("lc_phi", &lc_phi);
  tree->Branch("lc_x", &lc_x);
  tree->Branch("lc_y", &lc_y);
  tree->Branch("lc_z", &lc_z);
  tree->Branch("lc_algo", &lc_algo);
  tree->Branch("lc_layer", &lc_layer);
  tree->Branch("lc_nrechits", &lc_nrechits);
  tree->Branch("lc_tsMult", &lc_tsMult);
  tree->Branch("lc_mult", &lc_mult);

  tree->Branch("nAllLC", &nAllLC, "nAllLC/I");
  tree->Branch("all_lc_energy", &all_lc_energy);
  tree->Branch("all_lc_eta", &all_lc_eta);
  tree->Branch("all_lc_phi", &all_lc_phi);
  tree->Branch("all_lc_layer", &all_lc_layer);
  tree->Branch("all_lc_nrechits", &all_lc_nrechits);
  tree->Branch("all_lc_mult", &all_lc_mult);
  tree->Branch("all_lc_x", &all_lc_x);
  tree->Branch("all_lc_y", &all_lc_y);
  tree->Branch("all_lc_z", &all_lc_z);


  for (unsigned iL(0); iL<nL; ++iL){//loop on layers   
    std::ostringstream lName;
    lName << "nTriplets_" << iL+1;
    tree->Branch(lName.str().c_str(), &nTriplets[iL]);
    lName.str("");
    lName << "triplets_layerA_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_layerA[iL]);
    lName.str("");
    lName << "triplets_layerC_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_layerC[iL]);
    lName.str("");
    lName << "triplets_energyA_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_energyA[iL]);
    lName.str("");
    lName << "triplets_energyB_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_energyB[iL]);
    lName.str("");
    lName << "triplets_energyC_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_energyC[iL]);
    lName.str("");
    lName << "triplets_etaB_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_etaB[iL]);
    lName.str("");
    lName << "triplets_drB_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_drB[iL]);
    lName.str("");

    lName << "triplets_cosBeta_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_cosBeta[iL]);
    lName.str("");
    lName << "triplets_cosAlphaInner_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_cosAlphaInner[iL]);
    lName.str("");
    lName << "triplets_cosAlphaOuter_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_cosAlphaOuter[iL]);
    lName.str("");
    lName << "triplets_inner_in_links_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_inner_in_links[iL]);
    lName.str("");
    lName << "triplets_inner_out_links_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_inner_out_links[iL]);
    lName.str("");
    lName << "triplets_outer_in_links_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_outer_in_links[iL]);
    lName.str("");
    lName << "triplets_outer_out_links_" << iL+1;
    tree->Branch(lName.str().c_str(), &triplets_outer_out_links[iL]);
  }
  
}

HGCANALYZE::~HGCANALYZE() {}

void HGCANALYZE::fillHitMap(std::map<DetId, const HGCRecHit*>& hitMap,
                     const HGCRecHitCollection& rechitsEE,
                     const HGCRecHitCollection& rechitsFH,
                     const HGCRecHitCollection& rechitsBH) const {
  hitMap.clear();
  for (const auto& hit : rechitsEE) {
    hitMap.emplace(hit.detid(), &hit);
  }

  for (const auto& hit : rechitsFH) {
    hitMap.emplace(hit.detid(), &hit);
  }

  for (const auto& hit : rechitsBH) {
    hitMap.emplace(hit.detid(), &hit);
  }
}  // end of HGCANALYZE::fillHitMap


std::vector<int> HGCANALYZE::getClosestTrackstersToCPByIndex(const caloparticle& cp,
						      const reco::CaloClusterCollection& lcs,
                                                      const std::vector<ticl::Trackster>& trksters,
                                                      float maxDrTrksterCP) {
  std::vector<int> closestTrksters_;
  int idx = 0;
  for (auto const& t : trksters) {
    if (t.vertices().size()==0) continue;
    std::vector<layercluster> lcsFromTrkster;
    getLCsFromTrkster(t, lcs, lcsFromTrkster);
    std::sort(lcsFromTrkster.begin(), lcsFromTrkster.end(), sortLCsByEnergyAndLayer);
      
    float dr = reco::deltaR(cp.eta_, cp.phi_, lcsFromTrkster[0].eta_, lcsFromTrkster[0].phi_);
    if (dr < maxDrTrksterCP) {
      closestTrksters_.push_back(idx);
    }
    idx++;
  }
  return closestTrksters_;
}

int HGCANALYZE::isRecHitMatchedToCPRecHits(DetId detid_, const std::vector<DetId>& rechitdetid_) {
  auto found = std::find(std::begin(rechitdetid_), std::end(rechitdetid_), detid_);
  return (found != rechitdetid_.end()) ? std::distance(std::begin(rechitdetid_), found) : -1;
}  // end of matchRecHit2CPRecHits

double HGCANALYZE::getTrksterEnFromCP(const ticl::Trackster& trkster,
			       const reco::CaloClusterCollection& lcs,
			       const caloparticle& cp) {
  //std::cout << " IN getTrksterEnFromCP: cp E = " << cp.energy_ << std::endl;
  double enFromRecHits_ = 0.;

  // get the indices associated to the LCs of this trackster
  const std::vector<unsigned int>& lcIdxs_ = trkster.vertices();

  // loop over these idxs
  for (unsigned int ilc = 0; ilc < lcIdxs_.size(); ++ilc) {
    // get the lc and the corresponding rechits to this lc
    const reco::BasicCluster& lc = lcs[lcIdxs_[ilc]];
    auto const& hf = lc.hitsAndFractions();
    // loop over the rechits of this specific layer cluster
    for (unsigned int j = 0; j < hf.size(); j++) {
      const DetId detid_ = hf[j].first;
      int detid_idx = isRecHitMatchedToCPRecHits(detid_, cp.rechitdetid_);
      if (detid_idx >= 0) {
        enFromRecHits_ += cp.rechitenergy_[detid_idx];
      }
    }  // end of looping over the rechits
  }    // end of looping over the idxs

  //std::cout << " OUT E = " << enFromRecHits_ << std::endl;
  return enFromRecHits_;
}  // end of getTrksterEnFromCP

void HGCANALYZE::getLCs(const reco::CaloClusterCollection& lcs,
		 std::vector<layercluster> & layerclusters) {
  
  for (unsigned int ilc = 0; ilc < lcs.size(); ++ilc) {
    const reco::BasicCluster& lc = lcs.at(ilc);
    fillLCvector(layerclusters,lc,-2);
  }

}  // end of getLCs


void HGCANALYZE::getLCsFromTrkster(const ticl::Trackster& trkster,
			    const reco::CaloClusterCollection& lcs,
			    std::vector<layercluster> & layerclusters) {
  const std::vector<unsigned int>& lcIdxs = trkster.vertices();

  for (unsigned int ilc = 0; ilc < lcIdxs.size(); ++ilc) {
    const reco::BasicCluster& lc = lcs.at(lcIdxs[ilc]);
    fillLCvector(layerclusters,lc,trkster.vertex_multiplicity(ilc));
  }

}  // end of getLCsFromTrkster


void HGCANALYZE::fillLCvector(std::vector<layercluster> & aLCvec,
		       const reco::BasicCluster& aLC,
		       const int & tsMult){
  auto const& hf = aLC.hitsAndFractions();
  
  int layer_ = 0;
  for (unsigned int j = 0; j < hf.size(); j++) {
    const DetId detid_ = hf[j].first;
    layer_ = recHitTools->getLayerWithOffset(detid_);
    break;
  }
  //for (unsigned int j = 0; j < hf.size(); j++) {
  //std::cout << aLC.printHitAndFraction(j) << std::endl;
  //}
  
  aLCvec.push_back(layercluster());
  auto& layercluster_ = aLCvec.back();
  layercluster_.energy_ = aLC.energy();///(double)trkster.vertex_multiplicity(ilc);
  layercluster_.eta_ = aLC.eta();
  layercluster_.phi_ = aLC.phi();
  if (tsMult>-2){
    layercluster_.algo_ = aLC.algo();
    layercluster_.tsMult_ = tsMult;
  }
  
  layercluster_.x_ = aLC.position().x();
  layercluster_.y_ = aLC.position().y();
  layercluster_.z_ = aLC.position().z();
  layercluster_.nrechits_ = aLC.hitsAndFractions().size();
  layercluster_.layer_ = abs(layer_);
}

void HGCANALYZE::initialiseTreeVariables(){
  run = 0;
  lumi = 0;
  time = 0;
  event = 0;
  weight = 0;

  nTS = 0;
  trackster = -1;
  ts_energy = 0;
  ts_emEnergy = 0;
  ts_regEnergy = 0;
  ts_sigma1 = 0;
  ts_sigma2 = 0;
  ts_sigma3 = 0;
  ts_BCx = 0;
  ts_BCy = 0;
  ts_BCz = 0;
  ts_eta_PCA = 0;
  ts_phi_PCA = 0;
  ts_eta_fromLC = 0;
  ts_phi_fromLC = 0;
  ts_photon_proba = 0;
  ts_ele_proba = 0;
  ts_mu_proba = 0;
  ts_pi0_proba = 0;
  ts_chHad_proba = 0;
  ts_neHad_proba = 0;
  ts_ambg_proba = 0;
  ts_unkwn_proba = 0;
  ts_firstLayer = 0;
  ts_lastLayer = 0;
  ts_outInHopsPerformed = 0;

  nCP = 0;
  cp_missingEnergyFraction = 0;
  cp_energy = 0;
  cp_pdgid = 0;
  cp_pt = 0;
  cp_eta = 0;
  cp_phi = 0;


  nLC = 0;
  lc_energy.clear();
  lc_eta.clear();
  lc_phi.clear();
  lc_x.clear();
  lc_y.clear();
  lc_z.clear();
  lc_algo.clear();
  lc_layer.clear();
  lc_nrechits.clear();
  lc_tsMult.clear();
  lc_mult.clear();

  nAllLC = 0;
  all_lc_energy.clear();
  all_lc_eta.clear();
  all_lc_phi.clear();
  all_lc_layer.clear();
  all_lc_nrechits.clear();
  all_lc_mult.clear();
  all_lc_x.clear();
  all_lc_y.clear();
  all_lc_z.clear();

  for (unsigned iL(0); iL<nL; ++iL){//loop on layers   
    nTriplets[iL] = 0;
    triplets_layerA[iL].clear();
    triplets_layerC[iL].clear();
    triplets_energyA[iL].clear();
    triplets_energyB[iL].clear();
    triplets_energyC[iL].clear();
    triplets_etaB[iL].clear();
    triplets_drB[iL].clear();
    triplets_cosBeta[iL].clear();
    triplets_cosAlphaInner[iL].clear();
    triplets_cosAlphaOuter[iL].clear();
    triplets_inner_in_links[iL].clear();
    triplets_inner_out_links[iL].clear();
    triplets_outer_in_links[iL].clear();
    triplets_outer_out_links[iL].clear();
  }

};

void HGCANALYZE::fillDoubletsInfo(const ticl::Trackster & thisTrackster,
			   const reco::CaloClusterCollection &  layerClusters
			   ){
  //  std::cout<<"entering filling doublet"<<std::endl;
  std::vector<Triplet> tripletVec[28];
  for (unsigned iL(0); iL<nL; ++iL){//loop on layers   
    tripletVec[iL].reserve(10);
  }
  //loop on doublets: consider it is the outerDoublet.
  for (const auto &edge : thisTrackster.edges()) {//loop on edges
    //    std::cout<<"entering trackster loop"<<std::endl;

    auto & ic = layerClusters[edge[0]];//B
    auto & oc = layerClusters[edge[1]];//C
    auto const & cl_in = ic.hitsAndFractions()[0].first;
    auto const & cl_out = oc.hitsAndFractions()[0].first;
    auto const layer_in = recHitTools->getLayerWithOffset(cl_in);
    auto const layer_out = recHitTools->getLayerWithOffset(cl_out);
    
    //std::cout<<"layer_in,layer_out:"<<layer_in<<","<<layer_out<<std::endl;

    Triplet lTriplet;
    lTriplet.initialise();
    lTriplet.layerB_ = layer_in;
    lTriplet.layerC_ = layer_out;
    lTriplet.eB_ = ic.energy();
    lTriplet.eC_ = oc.energy();
    lTriplet.etaB_ = ic.eta();
    lTriplet.drB_ = sqrt( pow(thisTrackster.eigenvectors()[0].eta() - ic.eta() ,2) 
    			  + pow(thisTrackster.eigenvectors()[0].phi() - ic.phi() ,2) 
    			  );
    

    // Alpha angles
    const auto & outer_outer_pos = oc.position();
    const auto & outer_inner_pos = ic.position();
    //const auto & seed = thisTrackster.seedIndex();
    auto seedGlobalPos = math::XYZPoint(0,0,0);
    
    lTriplet.cosAlphaOuter_ = (outer_inner_pos-seedGlobalPos).Dot(outer_outer_pos - outer_inner_pos)/
      sqrt((outer_inner_pos-seedGlobalPos).Mag2()*(outer_outer_pos-outer_inner_pos).Mag2());
    
    // To complete the triplet, another inner loop
    // is therefore needed.
    std::vector<std::array<unsigned int, 2>> innerDoublets;
    std::vector<std::array<unsigned int, 2>> outerDoublets;
    for ( const auto & otherEdge : thisTrackster.edges()) {
      if (otherEdge[1] == edge[0]) {
	innerDoublets.push_back(otherEdge);
      }
      if (edge[1] == otherEdge[0]) {
	outerDoublets.push_back(otherEdge);
      }
    }
    
    lTriplet.outer_in_links_ = innerDoublets.size();
    lTriplet.outer_out_links_ = outerDoublets.size();

    if (innerDoublets.size()==0) {
      tripletVec[layer_in-1].push_back(lTriplet);
      nTriplets[layer_in-1]++;
    }

    for (const auto & inner : innerDoublets) {
      const auto & inner_ic = layerClusters[inner[0]];
      const auto & inner_inner_pos = inner_ic.position();

      lTriplet.cosBeta_ = (outer_inner_pos-inner_inner_pos).Dot(outer_outer_pos-inner_inner_pos)/
	sqrt((outer_inner_pos-inner_inner_pos).Mag2()*(outer_outer_pos-inner_inner_pos).Mag2());
      
      lTriplet.eA_ = inner_ic.energy();
      lTriplet.layerA_ = recHitTools->getLayerWithOffset(inner_ic.hitsAndFractions()[0].first);

      lTriplet.cosAlphaInner_ = (inner_inner_pos-seedGlobalPos).Dot(outer_inner_pos - inner_inner_pos)/
	sqrt((inner_inner_pos-seedGlobalPos).Mag2()*(outer_inner_pos-inner_inner_pos).Mag2());

      //get the number of links also for this inner doublet
      std::vector<std::array<unsigned int, 2>> IinnerDoublets;
      std::vector<std::array<unsigned int, 2>> IouterDoublets;
      for ( const auto & otherEdge : thisTrackster.edges()) {
	if (otherEdge[1] == edge[0]) {
	  IinnerDoublets.push_back(otherEdge);
	}
	if (edge[1] == otherEdge[0]) {
	  IouterDoublets.push_back(otherEdge);
	}
      }
    
      lTriplet.inner_in_links_ = IinnerDoublets.size();
      lTriplet.inner_out_links_ = IouterDoublets.size();

      tripletVec[layer_in-1].push_back(lTriplet);
      nTriplets[layer_in-1]++;

    }//loop on inner doublets
  }//loop on edges

  //  for (unsigned iL(0); iL<nL; ++iL){//loop on layers   
  //    std::cout<<"tripletvec size"<<tripletVec[iL].size()<<std::endl;
  //  }

  for (unsigned iL(0); iL<nL; ++iL){//loop on layers   
    //    std::cout << " -- Filling trackster triplets, layer " << iL+1 << " nTriplets=" << tripletVec[iL].size() << std::endl;
    
    triplets_layerA[iL].clear();
    triplets_layerC[iL].clear();
    triplets_energyA[iL].clear();
    triplets_energyB[iL].clear();
    triplets_energyC[iL].clear();
    triplets_etaB[iL].clear();
    triplets_drB[iL].clear();
    triplets_cosBeta[iL].clear();
    triplets_cosAlphaInner[iL].clear();
    triplets_cosAlphaOuter[iL].clear();
    triplets_inner_in_links[iL].clear();
    triplets_inner_out_links[iL].clear();
    triplets_outer_in_links[iL].clear();
    triplets_outer_out_links[iL].clear();
    triplets_layerA[iL].reserve(tripletVec[iL].size());
    triplets_layerC[iL].reserve(tripletVec[iL].size());
    triplets_energyA[iL].reserve(tripletVec[iL].size());
    triplets_energyB[iL].reserve(tripletVec[iL].size());
    triplets_energyC[iL].reserve(tripletVec[iL].size());
    triplets_etaB[iL].reserve(tripletVec[iL].size());
    triplets_drB[iL].reserve(tripletVec[iL].size());
    triplets_cosBeta[iL].reserve(tripletVec[iL].size());
    triplets_cosAlphaInner[iL].reserve(tripletVec[iL].size());
    triplets_cosAlphaOuter[iL].reserve(tripletVec[iL].size());
    triplets_inner_in_links[iL].reserve(tripletVec[iL].size());
    triplets_inner_out_links[iL].reserve(tripletVec[iL].size());
    triplets_outer_in_links[iL].reserve(tripletVec[iL].size());
    triplets_outer_out_links[iL].reserve(tripletVec[iL].size());
    
    for ( const auto & iTriplet : tripletVec[iL]){
      //      std::cout<<"pushing back"<<iTriplet.layerA_<<std::endl;
      triplets_layerA[iL].push_back(iTriplet.layerA_);
      triplets_layerC[iL].push_back(iTriplet.layerC_);
      triplets_energyA[iL].push_back(iTriplet.eA_);
      triplets_energyB[iL].push_back(iTriplet.eB_);
      triplets_energyC[iL].push_back(iTriplet.eC_);
      triplets_etaB[iL].push_back(iTriplet.etaB_);
      triplets_drB[iL].push_back(iTriplet.drB_);
      triplets_cosBeta[iL].push_back(iTriplet.cosBeta_);
      triplets_cosAlphaInner[iL].push_back(iTriplet.cosAlphaInner_);
      triplets_cosAlphaOuter[iL].push_back(iTriplet.cosAlphaOuter_);
      triplets_inner_in_links[iL].push_back(iTriplet.inner_in_links_);
      triplets_inner_out_links[iL].push_back(iTriplet.inner_out_links_);
      triplets_outer_in_links[iL].push_back(iTriplet.outer_in_links_);
      triplets_outer_out_links[iL].push_back(iTriplet.outer_out_links_);
    }
    //    std::cout << " -- Filled trackster triplets, layer " << iL+1 << " nTriplets=" << tripletVec[iL].size() << std::endl;

  }

}//fillDoubletsInfo



void HGCANALYZE::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) {
  using namespace edm;

  edm::Handle<HGCRecHitCollection> recHitHandleEE;
  iEvent.getByToken(hgcalRecHitsEEToken_, recHitHandleEE);

  edm::Handle<HGCRecHitCollection> recHitHandleFH;
  iEvent.getByToken(hgcalRecHitsFHToken_, recHitHandleFH);

  edm::Handle<HGCRecHitCollection> recHitHandleBH;
  iEvent.getByToken(hgcalRecHitsBHToken_, recHitHandleBH);


  //edm::Handle<std::vector<ticl::Trackster>> dummyTrksterHandle;
  //iEvent.getByToken(dummyTrksterToken_, dummyTrksterHandle);
  //const std::vector<ticl::Trackster>& dummyTrksters = *dummyTrksterHandle;

  //  edm::Handle<std::vector<ticl::Trackster>> emTrksterHandle;
  //  iEvent.getByToken(emTrksterToken_, emTrksterHandle);
  //  const std::vector<ticl::Trackster>& emTrksters = *emTrksterHandle;


  //edm::Handle<std::vector<ticl::Trackster>> trkTrksterHandle;
  //iEvent.getByToken(trkTrksterToken_, trkTrksterHandle);
  //const std::vector<ticl::Trackster>& trkTrksters = *trkTrksterHandle;

  //edm::Handle<std::vector<ticl::Trackster>> hadTrksterHandle;
  //iEvent.getByToken(hadTrksterToken_, hadTrksterHandle);
  //const std::vector<ticl::Trackster>& hadTrksters = *hadTrksterHandle;

  edm::Handle<std::vector<ticl::Trackster>> mergeTrksterHandle;
  iEvent.getByToken(mergeTrksterToken_, mergeTrksterHandle);
  const std::vector<ticl::Trackster>& mergeTrksters = *mergeTrksterHandle;

  edm::Handle<std::vector<CaloParticle>> CaloParticles;
  iEvent.getByToken(caloParticlesToken_, CaloParticles);
  const CaloParticleCollection& cps = *CaloParticles;

  edm::Handle<reco::CaloClusterCollection> layerClusterHandle;
  iEvent.getByToken(hgcalLayerClustersToken_, layerClusterHandle);
  const reco::CaloClusterCollection& lcs = *layerClusterHandle;

  std::map<DetId, const HGCRecHit*> hitMap;
  fillHitMap(hitMap, *recHitHandleEE, *recHitHandleFH, *recHitHandleBH);

  //edm::Handle<edm::ValueMap<std::pair<float, float>>> lcTimeHandle;
  //iEvent.getByToken(hgcalLayerClusterTimeToken_, lcTimeHandle);
  //const auto& lcTime = *lcTimeHandle;

  // init vars
  //recHitTools->getEventSetup(iSetup);

  initialiseTreeVariables();

  // get CaloParticles
  std::vector<caloparticle> caloparticles;
  int idx = -1;
  for (const auto& it_cp : cps) {
    const CaloParticle& cp = ((it_cp));
    idx++;

    if ((cp.eventId().event() != 0) || (cp.eventId().bunchCrossing() != 0)) {
      continue;
    }

    // allow CP only within HGCAL volume
    if ((abs(cp.eta()) < 1.2) || (abs(cp.eta()) > 3.5)) {
      continue;
    }

    caloparticle tmpcp_;
    tmpcp_.idx_ = idx;
    tmpcp_.pdgid_ = cp.pdgId();
    tmpcp_.energy_ = cp.energy();
    tmpcp_.pt_ = cp.pt();
    tmpcp_.eta_ = cp.eta();
    tmpcp_.phi_ = cp.phi();

    //std::cout << tmpcp_.print() << std::endl;

    std::vector<DetId> tmprechits_;
    std::vector<double> tmprechitenergy_;

    // get the simclusters
    const SimClusterRefVector& simclusters = cp.simClusters();
    for (const auto& it_simc : simclusters) {
      const SimCluster& simc = (*(it_simc));
      const auto& sc_haf = simc.hits_and_fractions();

      // get the rechits
      for (const auto& it_sc_haf : sc_haf) {
        DetId detid_ = (it_sc_haf.first);

        // need to map RecHits to the SimCluster
        // SimHits are not stored
        auto const itcheck = hitMap.find(detid_);
        // we need this check because some DetIDs assigned to CaloParticle do not always have
        // a RecHit -- due to thresholds or whatever
        if (itcheck != hitMap.end()) {
          const HGCRecHit* hit = itcheck->second;
          tmprechits_.push_back(detid_);
          tmprechitenergy_.push_back((it_sc_haf.second) * hit->energy());

        }  //  end of if(itcheck != hitMap.end())
      }    // end of looping over the rechits
    }      // end of looping over the sim clusters

    tmpcp_.rechitdetid_ = tmprechits_;
    tmpcp_.rechitenergy_ = tmprechitenergy_;
    caloparticles.push_back(tmpcp_);

  }  // end of looping over the calo particles

  // get the relevant trackster collection
  // LG: For now always use the MergedTrackster
  //   int cp_pdgid_ = 0; if (caloparticles.size()>0) { cp_pdgid_ = caloparticles.at(0).pdgid_; }
  //   std::vector<ticl::Trackster> tracksters = getTracksterCollection(cp_pdgid_,emMCs, mipMCs, hadMCs, mergedMCs);

  // loop over the caloparticles and then find the closest trackster to it

  // keep tracksters [and the corresponding LC] that
  // have at least some ammount of energy from the CP
  //   std::vector<trackster> trksterCollection; trksterCollection.clear();

  //double trackstersEnFromCP = 0.9;
  float maxDrTracksterCP = 0.3;
  auto const& tracksters = mergeTrksters;//emTrksters;//dummyTrksters;//mergeTrksters;  // if we need a different trackster collection this should go in the loop
  //auto const& tracksters = dummyTrksters;//mergeTrksters;  // if we need a different trackster collection this should go in the loop

  nCP = caloparticles.size();
  nTS = tracksters.size();

  for (unsigned int icp = 0; icp < caloparticles.size(); ++icp) {
    // get the relevant tracksterCollection based on the cp_id

    // find the tracksters within some DR from the CP
    std::vector<int> closestTracksters =
      getClosestTrackstersToCPByIndex(caloparticles[icp], lcs, tracksters, maxDrTracksterCP);

    // for those tracksters closest to the CP calculate the energy that is associated to the CP
    // and select the one with the closest Energy to the CP
    double trksterCPEnDiffMin_ = std::numeric_limits<double>::max();
    int itrksterMin_ = -1;
    for (int itrkster : closestTracksters) {
      double trksterEnFromCP_ = getTrksterEnFromCP(tracksters[itrkster], lcs, caloparticles[icp]);
      double trksterCPEnDiff = abs(caloparticles[icp].energy_ - trksterEnFromCP_) / (caloparticles[icp].energy_);
      if (trksterCPEnDiff < trksterCPEnDiffMin_) {
        trksterCPEnDiffMin_ = trksterCPEnDiff;
        //if (trksterCPEnDiff < trackstersEnFromCP) {
	itrksterMin_ = itrkster;
	cp_missingEnergyFraction = trksterCPEnDiff;
	//std::cout << " Chose trackster idx " << itrkster << " with E " << trksterEnFromCP_ << std::endl;
	//}
	//else std::cout << " Don't record missingE..." << std::endl;
      }
    }

    irun = iEvent.id().run();
    ievent = iEvent.id().event();
    ilumiblock = iEvent.id().luminosityBlock();
    itime = iEvent.time();
    
    run = (size_t)irun;
    event = (size_t)ievent;
    lumi = (size_t)ilumiblock;

    cp_energy = caloparticles[icp].energy_;
    cp_pt = caloparticles[icp].pt_;
    cp_eta = caloparticles[icp].eta_;
    cp_phi = caloparticles[icp].phi_;
    cp_pdgid = caloparticles[icp].pdgid_;
    
    lc_energy.clear();
    lc_eta.clear();
    lc_phi.clear();
    lc_x.clear();
    lc_y.clear();
    lc_z.clear();
    lc_algo.clear();
    lc_layer.clear();
    lc_nrechits.clear();
    lc_tsMult.clear();
    lc_mult.clear();

    all_lc_energy.clear();
    all_lc_eta.clear();
    all_lc_x.clear();
    all_lc_y.clear();
    all_lc_z.clear();
    all_lc_phi.clear();
    all_lc_layer.clear();
    all_lc_nrechits.clear();
    all_lc_mult.clear();


    std::vector<layercluster> alllcs;
    getLCs(lcs,alllcs);
    std::sort(alllcs.begin(), alllcs.end(), sortLCsByLayerAndEnergy);
    
    std::map<int,int>lMapLC;
    nAllLC = alllcs.size();
    for (auto const& lc : alllcs) {
      all_lc_energy.push_back(lc.energy_);
      all_lc_eta.push_back(lc.eta_);
      all_lc_x.push_back(lc.x_);
      all_lc_y.push_back(lc.y_);
      all_lc_z.push_back(lc.z_);
      all_lc_phi.push_back(lc.phi_);
      all_lc_layer.push_back(lc.layer_);
      std::pair<std::map<int,int>::iterator,bool> isInserted =  lMapLC.insert(std::pair<int,int>(lc.layer_,1));
      if (!isInserted.second) isInserted.first->second += 1;
      
      all_lc_nrechits.push_back(lc.nrechits_);
    }

    for (unsigned iL(0); iL<28;++iL){
      std::map<int,int>::iterator lEle = lMapLC.find(iL+1);
      if (lEle !=lMapLC.end()) all_lc_mult.push_back(lEle->second);
      else all_lc_mult.push_back(0);
    }

    trackster = itrksterMin_;
    if (itrksterMin_ >= 0) { 
      ts_emEnergy = tracksters[itrksterMin_].raw_em_energy();
      ts_energy = tracksters[itrksterMin_].raw_energy();
      ts_regEnergy = tracksters[itrksterMin_].regressed_energy();
      ts_sigma1 = tracksters[itrksterMin_].sigmasPCA()[0];
      ts_sigma2 = tracksters[itrksterMin_].sigmasPCA()[1];
      ts_sigma3 = tracksters[itrksterMin_].sigmasPCA()[2];
      ts_BCx = tracksters[itrksterMin_].barycenter().x();
      ts_BCy = tracksters[itrksterMin_].barycenter().y();
      ts_BCz = tracksters[itrksterMin_].barycenter().z();
      ts_eta_PCA = tracksters[itrksterMin_].eigenvectors()[0].eta();
      ts_phi_PCA = tracksters[itrksterMin_].eigenvectors()[0].phi();
      ts_outInHopsPerformed = tracksters[itrksterMin_].outInHopsPerformed();
      ts_photon_proba = tracksters[itrksterMin_].id_probability(ticl::Trackster::ParticleType::photon);
      ts_ele_proba = tracksters[itrksterMin_].id_probability(ticl::Trackster::ParticleType::electron);
      ts_mu_proba = tracksters[itrksterMin_].id_probability(ticl::Trackster::ParticleType::muon);
      ts_pi0_proba = tracksters[itrksterMin_].id_probability(ticl::Trackster::ParticleType:: neutral_pion);
      ts_chHad_proba = tracksters[itrksterMin_].id_probability(ticl::Trackster::ParticleType::charged_hadron);
      ts_neHad_proba = tracksters[itrksterMin_].id_probability(ticl::Trackster::ParticleType::neutral_hadron);
      ts_ambg_proba = tracksters[itrksterMin_].id_probability(ticl::Trackster::ParticleType::ambiguous);
      ts_unkwn_proba = tracksters[itrksterMin_].id_probability(ticl::Trackster::ParticleType::unknown);

      lMapLC.clear();
      
      std::vector<layercluster> lcsFromClosestTrksterToCP;
      getLCsFromTrkster(tracksters[itrksterMin_], lcs, lcsFromClosestTrksterToCP);
      std::sort(lcsFromClosestTrksterToCP.begin(), lcsFromClosestTrksterToCP.end(), sortLCsByEnergyAndLayer);

      ts_eta_fromLC = lcsFromClosestTrksterToCP[0].eta_;
      ts_phi_fromLC = lcsFromClosestTrksterToCP[0].phi_;

      int firstLay=30;
      int lastLay=0;
      nLC = lcsFromClosestTrksterToCP.size();
      for (auto const& lc : lcsFromClosestTrksterToCP) {
	lc_energy.push_back(lc.energy_);
        lc_eta.push_back(lc.eta_);
        lc_phi.push_back(lc.phi_);
	lc_x.push_back(lc.x_);
	lc_y.push_back(lc.y_);
	lc_z.push_back(lc.z_);
        lc_algo.push_back(lc.algo_);
        lc_layer.push_back(lc.layer_);
	std::pair<std::map<int,int>::iterator,bool> isInserted =  lMapLC.insert(std::pair<int,int>(lc.layer_,1));
	if (!isInserted.second) isInserted.first->second += 1;

	if (lc.layer_<firstLay) firstLay=lc.layer_;
	if (lc.layer_>lastLay) lastLay=lc.layer_;
        lc_nrechits.push_back(lc.nrechits_);
        lc_tsMult.push_back(lc.tsMult_);
      }

      for (unsigned iL(0); iL<28;++iL){
	std::map<int,int>::iterator lEle = lMapLC.find(iL+1);
	if (lEle !=lMapLC.end()) lc_mult.push_back(lEle->second);
	else lc_mult.push_back(0);
      }

      lMapLC.clear();

      ts_firstLayer = firstLay;
      ts_lastLayer = lastLay;
      //      if (tracksters[itrksterMin_].edges().empty())  {std::cout<<"tracksters edges empty"<<std::endl;}
      //      std::cout<<"tracksters edges"<<(tracksters[itrksterMin_].edges()).empty()<<std::endl;
      //      std::cout<<"tracksters verticles"<<(tracksters[itrksterMin_].vertices()).size()<<std::endl;
      fillDoubletsInfo(tracksters[itrksterMin_],lcs);

    }  // Loop on trackster associated to the CaloParticle
    
    tree->Fill();
    
  }    // end of looping over the caloparticles
}

// ------------ method called once each job just before starting event loop  ------------
void HGCANALYZE::beginJob() {}

// ------------ method called once each job just after ending the event loop  ------------
void HGCANALYZE::endJob() {}

// ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
void HGCANALYZE::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  //The following says we do not know what parameters are allowed so do no validation
  // Please change this to state exactly what you do use, even if it is no parameters
  edm::ParameterSetDescription desc;
  desc.setUnknown();
  descriptions.addDefault(desc);
}

//define this as a plug-in
DEFINE_FWK_MODULE(HGCANALYZE);
